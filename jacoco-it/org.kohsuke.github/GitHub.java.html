<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GitHub.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub API for Java</a> &gt; <a href="index.source.html" class="el_package">org.kohsuke.github</a> &gt; <span class="el_source">GitHub.java</span></div><h1>GitHub.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Copyright (c) 2010, Kohsuke Kawaguchi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.kohsuke.github;

import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.kohsuke.github.authorization.AuthorizationProvider;
import org.kohsuke.github.authorization.ImmutableAuthorizationProvider;
import org.kohsuke.github.authorization.UserAuthorizationProvider;
import org.kohsuke.github.connector.GitHubConnector;
import org.kohsuke.github.internal.GitHubConnectorHttpConnectorAdapter;
import org.kohsuke.github.internal.Previews;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Supplier;
import java.util.logging.Logger;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;

import static org.kohsuke.github.internal.Previews.INERTIA;
import static org.kohsuke.github.internal.Previews.MACHINE_MAN;

// TODO: Auto-generated Javadoc
/**
 * Root of the GitHub API.
 *
 * &lt;h2&gt;Thread safety&lt;/h2&gt;
 * &lt;p&gt;
 * This library aims to be safe for use by multiple threads concurrently, although the library itself makes no attempt
 * to control/serialize potentially conflicting operations to GitHub, such as updating &amp;amp; deleting a repository at
 * the same time.
 *
 * @author Kohsuke Kawaguchi
 */
public class GitHub {

    @Nonnull
    private final GitHubClient client;

    @CheckForNull
    private GHMyself myself;

    private final ConcurrentMap&lt;String, GHUser&gt; users;
    private final ConcurrentMap&lt;String, GHOrganization&gt; orgs;

<span class="fc" id="L73">    @Nonnull</span>
    private final GitHubSanityCachedValue&lt;GHMeta&gt; sanityCachedMeta = new GitHubSanityCachedValue&lt;&gt;();

    /**
     * Creates a client API root object.
     *
     * &lt;p&gt;
     * Several different combinations of the login/oauthAccessToken/password parameters are allowed to represent
     * different ways of authentication.
     *
     * &lt;dl&gt;
     * &lt;dt&gt;Log in anonymously
     * &lt;dd&gt;Leave all three parameters null and you will be making HTTP requests without any authentication.
     *
     * &lt;dt&gt;Log in with password
     * &lt;dd&gt;Specify the login and password, then leave oauthAccessToken null. This will use the HTTP BASIC auth with the
     * GitHub API.
     *
     * &lt;dt&gt;Log in with OAuth token
     * &lt;dd&gt;Specify oauthAccessToken, and optionally specify the login. Leave password null. This will send OAuth token
     * to the GitHub API. If the login parameter is null, The constructor makes an API call to figure out the user name
     * that owns the token.
     *
     * &lt;dt&gt;Log in with JWT token
     * &lt;dd&gt;Specify jwtToken. Leave password null. This will send JWT token to the GitHub API via the Authorization HTTP
     * header. Please note that only operations in which permissions have been previously configured and accepted during
     * the GitHub App will be executed successfully.
     * &lt;/dl&gt;
     *
     * @param apiUrl
     *            The URL of GitHub (or GitHub enterprise) API endpoint, such as &quot;https://api.github.com&quot; or
     *            &quot;http://ghe.acme.com/api/v3&quot;. Note that GitHub Enterprise has &lt;code&gt;/api/v3&lt;/code&gt; in the URL. For
     *            historical reasons, this parameter still accepts the bare domain name, but that's considered
     *            deprecated. Password is also considered deprecated as it is no longer required for api usage.
     * @param connector
     *            a connector
     * @param rateLimitHandler
     *            rateLimitHandler
     * @param abuseLimitHandler
     *            abuseLimitHandler
     * @param rateLimitChecker
     *            rateLimitChecker
     * @param authorizationProvider
     *            a authorization provider
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    GitHub(String apiUrl,
            GitHubConnector connector,
            GitHubRateLimitHandler rateLimitHandler,
            GitHubAbuseLimitHandler abuseLimitHandler,
            GitHubRateLimitChecker rateLimitChecker,
<span class="fc" id="L125">            AuthorizationProvider authorizationProvider) throws IOException {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (authorizationProvider instanceof DependentAuthorizationProvider) {</span>
<span class="fc" id="L127">            ((DependentAuthorizationProvider) authorizationProvider).bind(this);</span>
<span class="fc bfc" id="L128" title="All 4 branches covered.">        } else if (authorizationProvider instanceof ImmutableAuthorizationProvider</span>
                &amp;&amp; authorizationProvider instanceof UserAuthorizationProvider) {
<span class="fc" id="L130">            UserAuthorizationProvider provider = (UserAuthorizationProvider) authorizationProvider;</span>
<span class="pc bpc" id="L131" title="1 of 4 branches missed.">            if (provider.getLogin() == null &amp;&amp; provider.getEncodedAuthorization() != null</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">                    &amp;&amp; provider.getEncodedAuthorization().startsWith(&quot;token&quot;)) {</span>
<span class="fc" id="L133">                authorizationProvider = new LoginLoadingUserAuthorizationProvider(provider, this);</span>
            }
        }

<span class="fc" id="L137">        users = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L138">        orgs = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L140">        this.client = new GitHubClient(apiUrl,</span>
                connector,
                rateLimitHandler,
                abuseLimitHandler,
                rateLimitChecker,
                authorizationProvider);

        // Ensure we have the login if it is available
        // This preserves previously existing behavior. Consider removing in future.
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (authorizationProvider instanceof LoginLoadingUserAuthorizationProvider) {</span>
<span class="fc" id="L150">            ((LoginLoadingUserAuthorizationProvider) authorizationProvider).getLogin();</span>
        }
<span class="fc" id="L152">    }</span>

<span class="fc" id="L154">    private GitHub(GitHubClient client) {</span>
<span class="fc" id="L155">        users = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L156">        orgs = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L157">        this.client = client;</span>
<span class="fc" id="L158">    }</span>

    private static class LoginLoadingUserAuthorizationProvider implements UserAuthorizationProvider {
        private final GitHub gitHub;
        private final AuthorizationProvider authorizationProvider;
<span class="fc" id="L163">        private boolean loginLoaded = false;</span>
        private String login;

<span class="fc" id="L166">        LoginLoadingUserAuthorizationProvider(AuthorizationProvider authorizationProvider, GitHub gitHub) {</span>
<span class="fc" id="L167">            this.gitHub = gitHub;</span>
<span class="fc" id="L168">            this.authorizationProvider = authorizationProvider;</span>
<span class="fc" id="L169">        }</span>

        @Override
        public String getEncodedAuthorization() throws IOException {
<span class="fc" id="L173">            return authorizationProvider.getEncodedAuthorization();</span>
        }

        @Override
        public String getLogin() {
<span class="fc" id="L178">            synchronized (this) {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                if (!loginLoaded) {</span>
<span class="fc" id="L180">                    loginLoaded = true;</span>
                    try {
<span class="fc" id="L182">                        GHMyself u = gitHub.setMyself();</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                        if (u != null) {</span>
<span class="fc" id="L184">                            login = u.getLogin();</span>
                        }
<span class="nc" id="L186">                    } catch (IOException e) {</span>
<span class="fc" id="L187">                    }</span>
                }
<span class="fc" id="L189">                return login;</span>
            }
        }
    }

    /**
     * The Class DependentAuthorizationProvider.
     */
    public static abstract class DependentAuthorizationProvider implements AuthorizationProvider {

        private GitHub baseGitHub;
        private GitHub gitHub;
        private final AuthorizationProvider authorizationProvider;

        /**
         * An AuthorizationProvider that requires an authenticated GitHub instance to provide its authorization.
         *
         * @param authorizationProvider
         *            A authorization provider to be used when refreshing this authorization provider.
         */
        @BetaApi
<span class="fc" id="L210">        protected DependentAuthorizationProvider(AuthorizationProvider authorizationProvider) {</span>
<span class="fc" id="L211">            this.authorizationProvider = authorizationProvider;</span>
<span class="fc" id="L212">        }</span>

        /**
         * Binds this authorization provider to a github instance.
         *
         * Only needs to be implemented by dynamic credentials providers that use a github instance in order to refresh.
         *
         * @param github
         *            The github instance to be used for refreshing dynamic credentials
         */
        synchronized void bind(GitHub github) {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (baseGitHub != null) {</span>
<span class="nc" id="L224">                throw new IllegalStateException(&quot;Already bound to another GitHub instance.&quot;);</span>
            }
<span class="fc" id="L226">            this.baseGitHub = github;</span>
<span class="fc" id="L227">        }</span>

        /**
         * Git hub.
         *
         * @return the git hub
         */
        protected synchronized final GitHub gitHub() {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            if (gitHub == null) {</span>
<span class="fc" id="L236">                gitHub = new GitHub.AuthorizationRefreshGitHubWrapper(this.baseGitHub, authorizationProvider);</span>
            }
<span class="fc" id="L238">            return gitHub;</span>
        }
    }

    private static class AuthorizationRefreshGitHubWrapper extends GitHub {

        private final AuthorizationProvider authorizationProvider;

        AuthorizationRefreshGitHubWrapper(GitHub github, AuthorizationProvider authorizationProvider) {
<span class="fc" id="L247">            super(github.client);</span>
<span class="fc" id="L248">            this.authorizationProvider = authorizationProvider;</span>

            // no dependent authorization providers nest like this currently, but they might in future
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (authorizationProvider instanceof DependentAuthorizationProvider) {</span>
<span class="nc" id="L252">                ((DependentAuthorizationProvider) authorizationProvider).bind(this);</span>
            }
<span class="fc" id="L254">        }</span>

        @Nonnull
        @Override
        Requester createRequest() {
            try {
                // Override
<span class="fc" id="L261">                return super.createRequest().setHeader(&quot;Authorization&quot;, authorizationProvider.getEncodedAuthorization())</span>
<span class="fc" id="L262">                        .rateLimit(RateLimitTarget.NONE);</span>
<span class="nc" id="L263">            } catch (IOException e) {</span>
<span class="nc" id="L264">                throw new GHException(&quot;Failed to create requester to refresh credentials&quot;, e);</span>
            }
        }
    }

    /**
     * Obtains the credential from &quot;~/.github&quot; or from the System Environment Properties.
     *
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connect() throws IOException {
<span class="nc" id="L277">        return GitHubBuilder.fromCredentials().build();</span>
    }

    /**
     * Version that connects to GitHub Enterprise.
     *
     * @param apiUrl
     *            The URL of GitHub (or GitHub Enterprise) API endpoint, such as &quot;https://api.github.com&quot; or
     *            &quot;http://ghe.acme.com/api/v3&quot;. Note that GitHub Enterprise has &lt;code&gt;/api/v3&lt;/code&gt; in the URL. For
     *            historical reasons, this parameter still accepts the bare domain name, but that's considered
     *            deprecated.
     * @param oauthAccessToken
     *            the oauth access token
     * @return the git hub
     * @throws IOException
     *             the io exception
     * @deprecated Use {@link #connectToEnterpriseWithOAuth(String, String, String)}
     */
    @Deprecated
    public static GitHub connectToEnterprise(String apiUrl, String oauthAccessToken) throws IOException {
<span class="nc" id="L297">        return connectToEnterpriseWithOAuth(apiUrl, null, oauthAccessToken);</span>
    }

    /**
     * Version that connects to GitHub Enterprise.
     *
     * @param apiUrl
     *            The URL of GitHub (or GitHub Enterprise) API endpoint, such as &quot;https://api.github.com&quot; or
     *            &quot;http://ghe.acme.com/api/v3&quot;. Note that GitHub Enterprise has &lt;code&gt;/api/v3&lt;/code&gt; in the URL. For
     *            historical reasons, this parameter still accepts the bare domain name, but that's considered
     *            deprecated.
     * @param login
     *            the login
     * @param oauthAccessToken
     *            the oauth access token
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connectToEnterpriseWithOAuth(String apiUrl, String login, String oauthAccessToken)
            throws IOException {
<span class="nc" id="L318">        return new GitHubBuilder().withEndpoint(apiUrl).withOAuthToken(oauthAccessToken, login).build();</span>
    }

    /**
     * Version that connects to GitHub Enterprise.
     *
     * @param apiUrl
     *            the api url
     * @param login
     *            the login
     * @param password
     *            the password
     * @return the git hub
     * @throws IOException
     *             the io exception
     * @deprecated Use with caution. Login with password is not a preferred method.
     */
    @Deprecated
    public static GitHub connectToEnterprise(String apiUrl, String login, String password) throws IOException {
<span class="fc" id="L337">        return new GitHubBuilder().withEndpoint(apiUrl).withPassword(login, password).build();</span>
    }

    /**
     * Connect git hub.
     *
     * @param login
     *            the login
     * @param oauthAccessToken
     *            the oauth access token
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connect(String login, String oauthAccessToken) throws IOException {
<span class="nc" id="L352">        return new GitHubBuilder().withOAuthToken(oauthAccessToken, login).build();</span>
    }

    /**
     * Connect git hub.
     *
     * @param login
     *            the login
     * @param oauthAccessToken
     *            the oauth access token
     * @param password
     *            the password
     * @return the git hub
     * @throws IOException
     *             the io exception
     * @deprecated Use {@link #connectUsingOAuth(String)}.
     */
    @Deprecated
    public static GitHub connect(String login, String oauthAccessToken, String password) throws IOException {
<span class="nc" id="L371">        return new GitHubBuilder().withOAuthToken(oauthAccessToken, login).withPassword(login, password).build();</span>
    }

    /**
     * Connect using password git hub.
     *
     * @param login
     *            the login
     * @param password
     *            the password
     * @return the git hub
     * @throws IOException
     *             the io exception
     * @see &lt;a href=
     *      &quot;https://developer.github.com/changes/2020-02-14-deprecating-password-auth/#changes-to-make&quot;&gt;Deprecating
     *      password authentication and OAuth authorizations API&lt;/a&gt;
     * @deprecated Use {@link #connectUsingOAuth(String)} instead.
     */
    @Deprecated
    public static GitHub connectUsingPassword(String login, String password) throws IOException {
<span class="fc" id="L391">        return new GitHubBuilder().withPassword(login, password).build();</span>
    }

    /**
     * Connect using o auth git hub.
     *
     * @param oauthAccessToken
     *            the oauth access token
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connectUsingOAuth(String oauthAccessToken) throws IOException {
<span class="nc" id="L404">        return new GitHubBuilder().withOAuthToken(oauthAccessToken).build();</span>
    }

    /**
     * Connect using o auth git hub.
     *
     * @param githubServer
     *            the github server
     * @param oauthAccessToken
     *            the oauth access token
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connectUsingOAuth(String githubServer, String oauthAccessToken) throws IOException {
<span class="nc" id="L419">        return new GitHubBuilder().withEndpoint(githubServer).withOAuthToken(oauthAccessToken).build();</span>
    }

    /**
     * Connects to GitHub anonymously.
     * &lt;p&gt;
     * All operations that require authentication will fail.
     *
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connectAnonymously() throws IOException {
<span class="nc" id="L432">        return new GitHubBuilder().build();</span>
    }

    /**
     * Connects to GitHub Enterprise anonymously.
     * &lt;p&gt;
     * All operations that require authentication will fail.
     *
     * @param apiUrl
     *            the api url
     * @return the git hub
     * @throws IOException
     *             the io exception
     */
    public static GitHub connectToEnterpriseAnonymously(String apiUrl) throws IOException {
<span class="fc" id="L447">        return new GitHubBuilder().withEndpoint(apiUrl).build();</span>
    }

    /**
     * An offline-only {@link GitHub} useful for parsing event notification from an unknown source.
     * &lt;p&gt;
     * All operations that require a connection will fail.
     *
     * @return An offline-only {@link GitHub}.
     */
    public static GitHub offline() {
        try {
<span class="fc" id="L459">            return new GitHubBuilder().withEndpoint(&quot;https://api.github.invalid&quot;)</span>
<span class="fc" id="L460">                    .withConnector(GitHubConnector.OFFLINE)</span>
<span class="fc" id="L461">                    .build();</span>
<span class="nc" id="L462">        } catch (IOException e) {</span>
<span class="nc" id="L463">            throw new IllegalStateException(&quot;The offline implementation constructor should not connect&quot;, e);</span>
        }
    }

    /**
     * Is this an anonymous connection.
     *
     * @return {@code true} if operations that require authentication will fail.
     */
    public boolean isAnonymous() {
<span class="fc" id="L473">        return client.isAnonymous();</span>
    }

    /**
     * Is this an always offline &quot;connection&quot;.
     *
     * @return {@code true} if this is an always offline &quot;connection&quot;.
     */
    public boolean isOffline() {
<span class="fc" id="L482">        return client.isOffline();</span>
    }

    /**
     * Gets connector.
     *
     * @return the connector
     * @deprecated HttpConnector has been replaced by GitHubConnector which is generally not useful outside of this
     *             library. If you are using this method, file an issue describing your use case.
     */
    @Deprecated
    public HttpConnector getConnector() {
<span class="fc" id="L494">        return client.getConnector();</span>
    }

    /**
     * Sets the custom connector used to make requests to GitHub.
     *
     * @param connector
     *            the connector
     * @deprecated HttpConnector should not be changed. If you find yourself needing to do this, file an issue.
     */
    @Deprecated
    public void setConnector(@Nonnull HttpConnector connector) {
<span class="fc" id="L506">        client.setConnector(GitHubConnectorHttpConnectorAdapter.adapt(connector));</span>
<span class="fc" id="L507">    }</span>

    /**
     * Gets api url.
     *
     * @return the api url
     */
    public String getApiUrl() {
<span class="fc" id="L515">        return client.getApiUrl();</span>
    }

    /**
     * Gets the current full rate limit information from the server.
     *
     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In that
     * case, the most recent {@link GHRateLimit} information will be returned, including rate limit information returned
     * in the response header for this request in if was present.
     *
     * For most use cases it would be better to implement a {@link RateLimitChecker} and add it via
     * {@link GitHubBuilder#withRateLimitChecker(RateLimitChecker)}.
     *
     * @return the rate limit
     * @throws IOException
     *             the io exception
     */
    @Nonnull
    public GHRateLimit getRateLimit() throws IOException {
<span class="fc" id="L534">        return client.getRateLimit();</span>
    }

    /**
     * Returns the most recently observed rate limit data or {@code null} if either there is no rate limit (for example
     * GitHub Enterprise) or if no requests have been made.
     *
     * @return the most recently observed rate limit data or {@code null}.
     * @deprecated implement a {@link RateLimitChecker} and add it via
     *             {@link GitHubBuilder#withRateLimitChecker(RateLimitChecker)}.
     */
    @Nonnull
    @Deprecated
    public GHRateLimit lastRateLimit() {
<span class="fc" id="L548">        return client.lastRateLimit();</span>
    }

    /**
     * Gets the current rate limit while trying not to actually make any remote requests unless absolutely necessary.
     *
     * @return the current rate limit data.
     * @throws IOException
     *             if we couldn't get the current rate limit data.
     * @deprecated implement a {@link RateLimitChecker} and add it via
     *             {@link GitHubBuilder#withRateLimitChecker(RateLimitChecker)}.
     */
    @Nonnull
    @Deprecated
    public GHRateLimit rateLimit() throws IOException {
<span class="fc" id="L563">        return client.rateLimit(RateLimitTarget.CORE);</span>
    }

    /**
     * Gets the {@link GHUser} that represents yourself.
     *
     * @return the myself
     * @throws IOException
     *             the io exception
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Expected&quot;)
    @WithBridgeMethods(value = GHUser.class)
    public GHMyself getMyself() throws IOException {
<span class="fc" id="L576">        client.requireCredential();</span>
<span class="fc" id="L577">        return setMyself();</span>
    }

    private GHMyself setMyself() throws IOException {
<span class="fc" id="L581">        synchronized (this) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (this.myself == null) {</span>
<span class="fc" id="L583">                this.myself = createRequest().withUrlPath(&quot;/user&quot;).fetch(GHMyself.class);</span>
            }
<span class="fc" id="L585">            return myself;</span>
        }
    }

    /**
     * Obtains the object that represents the named user.
     *
     * @param login
     *            the login
     * @return the user
     * @throws IOException
     *             the io exception
     */
    public GHUser getUser(String login) throws IOException {
<span class="fc" id="L599">        GHUser u = users.get(login);</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (u == null) {</span>
<span class="fc" id="L601">            u = createRequest().withUrlPath(&quot;/users/&quot; + login).fetch(GHUser.class);</span>
<span class="fc" id="L602">            users.put(u.getLogin(), u);</span>
        }
<span class="fc" id="L604">        return u;</span>
    }

    /**
     * clears all cached data in order for external changes (modifications and del) to be reflected.
     */
    public void refreshCache() {
<span class="fc" id="L611">        users.clear();</span>
<span class="fc" id="L612">        orgs.clear();</span>
<span class="fc" id="L613">    }</span>

    /**
     * Interns the given {@link GHUser}.
     *
     * @param orig
     *            the orig
     * @return the user
     */
    protected GHUser getUser(GHUser orig) {
<span class="fc" id="L623">        GHUser u = users.get(orig.getLogin());</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">        if (u == null) {</span>
<span class="fc" id="L625">            users.put(orig.getLogin(), orig);</span>
<span class="fc" id="L626">            return orig;</span>
        }
<span class="fc" id="L628">        return u;</span>
    }

    /**
     * Gets {@link GHOrganization} specified by name.
     *
     * @param name
     *            the name
     * @return the organization
     * @throws IOException
     *             the io exception
     */
    public GHOrganization getOrganization(String name) throws IOException {
<span class="fc" id="L641">        GHOrganization o = orgs.get(name);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (o == null) {</span>
<span class="fc" id="L643">            o = createRequest().withUrlPath(&quot;/orgs/&quot; + name).fetch(GHOrganization.class);</span>
<span class="fc" id="L644">            orgs.put(name, o);</span>
        }
<span class="fc" id="L646">        return o;</span>
    }

    /**
     * Gets a list of all organizations.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHOrganization&gt; listOrganizations() {
<span class="fc" id="L655">        return listOrganizations(null);</span>
    }

    /**
     * Gets a list of all organizations starting after the organization identifier specified by 'since'.
     *
     * @param since
     *            the since
     * @return the paged iterable
     * @see &lt;a href=&quot;https://developer.github.com/v3/orgs/#parameters&quot;&gt;List All Orgs - Parameters&lt;/a&gt;
     */
    public PagedIterable&lt;GHOrganization&gt; listOrganizations(final String since) {
<span class="fc" id="L667">        return createRequest().with(&quot;since&quot;, since)</span>
<span class="fc" id="L668">                .withUrlPath(&quot;/organizations&quot;)</span>
<span class="fc" id="L669">                .toIterable(GHOrganization[].class, null);</span>
    }

    /**
     * Gets the repository object from 'owner/repo' string that GitHub calls as &quot;repository name&quot;.
     *
     * @param name
     *            the name
     * @return the repository
     * @throws IOException
     *             the io exception
     * @see GHRepository#getName() GHRepository#getName()
     */
    public GHRepository getRepository(String name) throws IOException {
<span class="fc" id="L683">        String[] tokens = name.split(&quot;/&quot;);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">        if (tokens.length != 2) {</span>
<span class="fc" id="L685">            throw new IllegalArgumentException(&quot;Repository name must be in format owner/repo&quot;);</span>
        }
<span class="fc" id="L687">        return GHRepository.read(this, tokens[0], tokens[1]);</span>
    }

    /**
     * Gets the repository object from its ID.
     *
     * @param id
     *            the id
     * @return the repository by id
     * @throws IOException
     *             the io exception
     * @deprecated Do not use this method. It was added due to misunderstanding of the type of parameter. Use
     *             {@link #getRepositoryById(long)} instead
     */
    @Deprecated
    public GHRepository getRepositoryById(String id) throws IOException {
<span class="fc" id="L703">        return createRequest().withUrlPath(&quot;/repositories/&quot; + id).fetch(GHRepository.class);</span>
    }

    /**
     * Gets the repository object from its ID.
     *
     * @param id
     *            the id
     * @return the repository by id
     * @throws IOException
     *             the io exception
     */
    public GHRepository getRepositoryById(long id) throws IOException {
<span class="fc" id="L716">        return createRequest().withUrlPath(&quot;/repositories/&quot; + id).fetch(GHRepository.class);</span>
    }

    /**
     * Returns a list of popular open source licenses.
     *
     * @return a list of popular open source licenses
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/licenses/&quot;&gt;GitHub API - Licenses&lt;/a&gt;
     */
    public PagedIterable&lt;GHLicense&gt; listLicenses() throws IOException {
<span class="fc" id="L728">        return createRequest().withUrlPath(&quot;/licenses&quot;).toIterable(GHLicense[].class, null);</span>
    }

    /**
     * Returns a list of all users.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHUser&gt; listUsers() throws IOException {
<span class="fc" id="L739">        return createRequest().withUrlPath(&quot;/users&quot;).toIterable(GHUser[].class, null);</span>
    }

    /**
     * Returns the full details for a license.
     *
     * @param key
     *            The license key provided from the API
     * @return The license details
     * @throws IOException
     *             the io exception
     * @see GHLicense#getKey() GHLicense#getKey()
     */
    public GHLicense getLicense(String key) throws IOException {
<span class="fc" id="L753">        return createRequest().withUrlPath(&quot;/licenses/&quot; + key).fetch(GHLicense.class);</span>
    }

    /**
     * Returns a list all plans for your Marketplace listing
     * &lt;p&gt;
     * GitHub Apps must use a JWT to access this endpoint.
     * &lt;p&gt;
     * OAuth Apps must use basic authentication with their client ID and client secret to access this endpoint.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/apps/marketplace/#list-all-plans-for-your-marketplace-listing&quot;&gt;List
     *      Plans&lt;/a&gt;
     */
    public PagedIterable&lt;GHMarketplacePlan&gt; listMarketplacePlans() throws IOException {
<span class="fc" id="L770">        return createRequest().withUrlPath(&quot;/marketplace_listing/plans&quot;).toIterable(GHMarketplacePlan[].class, null);</span>
    }

    /**
     * Gets complete list of open invitations for current user.
     *
     * @return the my invitations
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHInvitation&gt; getMyInvitations() throws IOException {
<span class="nc" id="L781">        return createRequest().withUrlPath(&quot;/user/repository_invitations&quot;)</span>
<span class="nc" id="L782">                .toIterable(GHInvitation[].class, null)</span>
<span class="nc" id="L783">                .toList();</span>
    }

    /**
     * This method returns shallowly populated organizations.
     * &lt;p&gt;
     * To retrieve full organization details, you need to call {@link #getOrganization(String)} TODO: make this
     * automatic.
     *
     * @return the my organizations
     * @throws IOException
     *             the io exception
     */
    public Map&lt;String, GHOrganization&gt; getMyOrganizations() throws IOException {
<span class="fc" id="L797">        GHOrganization[] orgs = createRequest().withUrlPath(&quot;/user/orgs&quot;)</span>
<span class="fc" id="L798">                .toIterable(GHOrganization[].class, null)</span>
<span class="fc" id="L799">                .toArray();</span>
<span class="fc" id="L800">        Map&lt;String, GHOrganization&gt; r = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">        for (GHOrganization o : orgs) {</span>
            // don't put 'o' into orgs because they are shallow
<span class="fc" id="L803">            r.put(o.getLogin(), o);</span>
        }
<span class="fc" id="L805">        return r;</span>
    }

    /**
     * Returns only active subscriptions.
     * &lt;p&gt;
     * You must use a user-to-server OAuth access token, created for a user who has authorized your GitHub App, to
     * access this endpoint
     * &lt;p&gt;
     * OAuth Apps must authenticate using an OAuth token.
     *
     * @return the paged iterable of GHMarketplaceUserPurchase
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/apps/marketplace/#get-a-users-marketplace-purchases&quot;&gt;Get a user's
     *      Marketplace purchases&lt;/a&gt;
     */
    public PagedIterable&lt;GHMarketplaceUserPurchase&gt; getMyMarketplacePurchases() throws IOException {
<span class="fc" id="L823">        return createRequest().withUrlPath(&quot;/user/marketplace_purchases&quot;)</span>
<span class="fc" id="L824">                .toIterable(GHMarketplaceUserPurchase[].class, null);</span>
    }

    /**
     * Alias for {@link #getUserPublicOrganizations(String)}.
     *
     * @param user
     *            the user
     * @return the user public organizations
     * @throws IOException
     *             the io exception
     */
    public Map&lt;String, GHOrganization&gt; getUserPublicOrganizations(GHUser user) throws IOException {
<span class="fc" id="L837">        return getUserPublicOrganizations(user.getLogin());</span>
    }

    /**
     * This method returns a shallowly populated organizations.
     * &lt;p&gt;
     * To retrieve full organization details, you need to call {@link #getOrganization(String)}
     *
     * @param login
     *            the user to retrieve public Organization membership information for
     * @return the public Organization memberships for the user
     * @throws IOException
     *             the io exception
     */
    public Map&lt;String, GHOrganization&gt; getUserPublicOrganizations(String login) throws IOException {
<span class="fc" id="L852">        GHOrganization[] orgs = createRequest().withUrlPath(&quot;/users/&quot; + login + &quot;/orgs&quot;)</span>
<span class="fc" id="L853">                .toIterable(GHOrganization[].class, null)</span>
<span class="fc" id="L854">                .toArray();</span>
<span class="fc" id="L855">        Map&lt;String, GHOrganization&gt; r = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        for (GHOrganization o : orgs) {</span>
            // don't put 'o' into orgs cache because they are shallow records
<span class="fc" id="L858">            r.put(o.getLogin(), o);</span>
        }
<span class="fc" id="L860">        return r;</span>
    }

    /**
     * Gets complete map of organizations/teams that current user belongs to.
     * &lt;p&gt;
     * Leverages the new GitHub API /user/teams made available recently to get in a single call the complete set of
     * organizations, teams and permissions in a single call.
     *
     * @return the my teams
     * @throws IOException
     *             the io exception
     */
    public Map&lt;String, Set&lt;GHTeam&gt;&gt; getMyTeams() throws IOException {
<span class="fc" id="L874">        Map&lt;String, Set&lt;GHTeam&gt;&gt; allMyTeams = new HashMap&lt;&gt;();</span>
<span class="fc" id="L875">        for (GHTeam team : createRequest().withUrlPath(&quot;/user/teams&quot;)</span>
<span class="fc" id="L876">                .toIterable(GHTeam[].class, item -&gt; item.wrapUp(this))</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">                .toArray()) {</span>
<span class="fc" id="L878">            String orgLogin = team.getOrganization().getLogin();</span>
<span class="fc" id="L879">            Set&lt;GHTeam&gt; teamsPerOrg = allMyTeams.get(orgLogin);</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">            if (teamsPerOrg == null) {</span>
<span class="fc" id="L881">                teamsPerOrg = new HashSet&lt;&gt;();</span>
            }
<span class="fc" id="L883">            teamsPerOrg.add(team);</span>
<span class="fc" id="L884">            allMyTeams.put(orgLogin, teamsPerOrg);</span>
        }
<span class="fc" id="L886">        return allMyTeams;</span>
    }

    /**
     * Gets a single team by ID.
     * &lt;p&gt;
     * This method is no longer supported and throws an UnsupportedOperationException.
     *
     * @param id
     *            the id
     * @return the team
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/teams/#get-team-legacy&quot;&gt;deprecation notice&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.blog/changelog/2022-02-22-sunset-notice-deprecated-teams-api-endpoints/&quot;&gt;sunset
     *      notice&lt;/a&gt;
     * @deprecated Use {@link GHOrganization#getTeam(long)}
     */
    @Deprecated
    public GHTeam getTeam(int id) throws IOException {
<span class="fc" id="L906">        throw new UnsupportedOperationException(</span>
                &quot;This method is not supported anymore. Please use GHOrganization#getTeam(long).&quot;);
    }

    /**
     * Public events visible to you. Equivalent of what's displayed on https://github.com/
     *
     * @return the events
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHEventInfo&gt; getEvents() throws IOException {
<span class="fc" id="L918">        return createRequest().withUrlPath(&quot;/events&quot;).toIterable(GHEventInfo[].class, null).toList();</span>
    }

    /**
     * List public events for a user
     * &lt;a href=&quot;https://docs.github.com/en/rest/activity/events?apiVersion=2022-11-28#list-public-events-for-a-user&quot;&gt;see
     * API documentation&lt;/a&gt;
     *
     * @param login
     *            the login (user) to look public events for
     * @return the events
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHEventInfo&gt; getUserPublicEvents(String login) throws IOException {
<span class="fc" id="L933">        return createRequest().withUrlPath(&quot;/users/&quot; + login + &quot;/events/public&quot;)</span>
<span class="fc" id="L934">                .toIterable(GHEventInfo[].class, null)</span>
<span class="fc" id="L935">                .toList();</span>
    }

    /**
     * Gets a single gist by ID.
     *
     * @param id
     *            the id
     * @return the gist
     * @throws IOException
     *             the io exception
     */
    public GHGist getGist(String id) throws IOException {
<span class="fc" id="L948">        return createRequest().withUrlPath(&quot;/gists/&quot; + id).fetch(GHGist.class);</span>
    }

    /**
     * Create gist gh gist builder.
     *
     * @return the gh gist builder
     */
    public GHGistBuilder createGist() {
<span class="fc" id="L957">        return new GHGistBuilder(this);</span>
    }

    /**
     * Parses the GitHub event object.
     * &lt;p&gt;
     * This is primarily intended for receiving a POST HTTP call from a hook. Unfortunately, hook script payloads aren't
     * self-descriptive, so you need to know the type of the payload you are expecting.
     *
     * @param &lt;T&gt;
     *            the type parameter
     * @param r
     *            the r
     * @param type
     *            the type
     * @return the t
     * @throws IOException
     *             the io exception
     */
    public &lt;T extends GHEventPayload&gt; T parseEventPayload(Reader r, Class&lt;T&gt; type) throws IOException {
<span class="fc" id="L977">        T t = GitHubClient.getMappingObjectReader(this).forType(type).readValue(r);</span>
<span class="fc" id="L978">        t.lateBind();</span>
<span class="fc" id="L979">        return t;</span>
    }

    /**
     * Creates a new repository.
     *
     * @param name
     *            the name
     * @param description
     *            the description
     * @param homepage
     *            the homepage
     * @param isPublic
     *            the is public
     * @return Newly created repository.
     * @throws IOException
     *             the io exception
     * @deprecated Use {@link #createRepository(String)} that uses a builder pattern to let you control every aspect.
     */
    @Deprecated
    public GHRepository createRepository(String name, String description, String homepage, boolean isPublic)
            throws IOException {
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        return createRepository(name).description(description).homepage(homepage).private_(!isPublic).create();</span>
    }

    /**
     * Starts a builder that creates a new repository.
     *
     * &lt;p&gt;
     * You use the returned builder to set various properties, then call {@link GHCreateRepositoryBuilder#create()} to
     * finally create a repository.
     *
     * &lt;p&gt;
     * To create a repository in an organization, see
     * {@link GHOrganization#createRepository(String, String, String, GHTeam, boolean)}
     *
     * @param name
     *            the name
     * @return the gh create repository builder
     */
    public GHCreateRepositoryBuilder createRepository(String name) {
<span class="fc" id="L1020">        return new GHCreateRepositoryBuilder(name, this, &quot;/user/repos&quot;);</span>
    }

    /**
     * Creates a new authorization.
     * &lt;p&gt;
     * The token created can be then used for {@link GitHub#connectUsingOAuth(String)} in the future.
     *
     * @param scope
     *            the scope
     * @param note
     *            the note
     * @param noteUrl
     *            the note url
     * @return the gh authorization
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;http://developer.github.com/v3/oauth/#create-a-new-authorization&quot;&gt;Documentation&lt;/a&gt;
     */
    public GHAuthorization createToken(Collection&lt;String&gt; scope, String note, String noteUrl) throws IOException {
<span class="fc" id="L1040">        Requester requester = createRequest().with(&quot;scopes&quot;, scope).with(&quot;note&quot;, note).with(&quot;note_url&quot;, noteUrl);</span>

<span class="nc" id="L1042">        return requester.method(&quot;POST&quot;).withUrlPath(&quot;/authorizations&quot;).fetch(GHAuthorization.class);</span>
    }

    /**
     * Creates a new authorization using an OTP.
     * &lt;p&gt;
     * Start by running createToken, if exception is thrown, prompt for OTP from user
     * &lt;p&gt;
     * Once OTP is received, call this token request
     * &lt;p&gt;
     * The token created can be then used for {@link GitHub#connectUsingOAuth(String)} in the future.
     *
     * @param scope
     *            the scope
     * @param note
     *            the note
     * @param noteUrl
     *            the note url
     * @param OTP
     *            the otp
     * @return the gh authorization
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;http://developer.github.com/v3/oauth/#create-a-new-authorization&quot;&gt;Documentation&lt;/a&gt;
     */
    public GHAuthorization createToken(Collection&lt;String&gt; scope, String note, String noteUrl, Supplier&lt;String&gt; OTP)
            throws IOException {
        try {
<span class="nc" id="L1070">            return createToken(scope, note, noteUrl);</span>
<span class="fc" id="L1071">        } catch (GHOTPRequiredException ex) {</span>
<span class="fc" id="L1072">            String OTPstring = OTP.get();</span>
<span class="fc" id="L1073">            Requester requester = createRequest().with(&quot;scopes&quot;, scope).with(&quot;note&quot;, note).with(&quot;note_url&quot;, noteUrl);</span>
            // Add the OTP from the user
<span class="fc" id="L1075">            requester.setHeader(&quot;x-github-otp&quot;, OTPstring);</span>
<span class="fc" id="L1076">            return requester.method(&quot;POST&quot;).withUrlPath(&quot;/authorizations&quot;).fetch(GHAuthorization.class);</span>
        }
    }

    /**
     * Create or get auth gh authorization.
     *
     * @param clientId
     *            the client id
     * @param clientSecret
     *            the client secret
     * @param scopes
     *            the scopes
     * @param note
     *            the note
     * @param note_url
     *            the note url
     * @return the gh authorization
     * @throws IOException
     *             the io exception
     * @see &lt;a href=
     *      &quot;https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app&quot;&gt;docs&lt;/a&gt;
     */
    public GHAuthorization createOrGetAuth(String clientId,
            String clientSecret,
            List&lt;String&gt; scopes,
            String note,
            String note_url) throws IOException {
<span class="nc" id="L1104">        Requester requester = createRequest().with(&quot;client_secret&quot;, clientSecret)</span>
<span class="nc" id="L1105">                .with(&quot;scopes&quot;, scopes)</span>
<span class="nc" id="L1106">                .with(&quot;note&quot;, note)</span>
<span class="nc" id="L1107">                .with(&quot;note_url&quot;, note_url);</span>

<span class="nc" id="L1109">        return requester.method(&quot;PUT&quot;).withUrlPath(&quot;/authorizations/clients/&quot; + clientId).fetch(GHAuthorization.class);</span>
    }

    /**
     * Delete auth.
     *
     * @param id
     *            the id
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization&quot;&gt;Delete an
     *      authorization&lt;/a&gt;
     */
    public void deleteAuth(long id) throws IOException {
<span class="nc" id="L1123">        createRequest().method(&quot;DELETE&quot;).withUrlPath(&quot;/authorizations/&quot; + id).send();</span>
<span class="nc" id="L1124">    }</span>

    /**
     * Check auth gh authorization.
     *
     * @param clientId
     *            the client id
     * @param accessToken
     *            the access token
     * @return the gh authorization
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/oauth_authorizations/#check-an-authorization&quot;&gt;Check an
     *      authorization&lt;/a&gt;
     */
    public GHAuthorization checkAuth(@Nonnull String clientId, @Nonnull String accessToken) throws IOException {
<span class="nc" id="L1140">        return createRequest().withUrlPath(&quot;/applications/&quot; + clientId + &quot;/tokens/&quot; + accessToken)</span>
<span class="nc" id="L1141">                .fetch(GHAuthorization.class);</span>
    }

    /**
     * Reset auth gh authorization.
     *
     * @param clientId
     *            the client id
     * @param accessToken
     *            the access token
     * @return the gh authorization
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/oauth_authorizations/#reset-an-authorization&quot;&gt;Reset an
     *      authorization&lt;/a&gt;
     */
    public GHAuthorization resetAuth(@Nonnull String clientId, @Nonnull String accessToken) throws IOException {
<span class="nc" id="L1158">        return createRequest().method(&quot;POST&quot;)</span>
<span class="nc" id="L1159">                .withUrlPath(&quot;/applications/&quot; + clientId + &quot;/tokens/&quot; + accessToken)</span>
<span class="nc" id="L1160">                .fetch(GHAuthorization.class);</span>
    }

    /**
     * Returns a list of all authorizations.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations&quot;&gt;List your
     *      authorizations&lt;/a&gt;
     */
    public PagedIterable&lt;GHAuthorization&gt; listMyAuthorizations() throws IOException {
<span class="fc" id="L1173">        return createRequest().withUrlPath(&quot;/authorizations&quot;).toIterable(GHAuthorization[].class, null);</span>
    }

    /**
     * Returns the GitHub App associated with the authentication credentials used.
     * &lt;p&gt;
     * You must use a JWT to access this endpoint.
     *
     * @return the app
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/apps/#get-the-authenticated-github-app&quot;&gt;Get the authenticated
     *      GitHub App&lt;/a&gt;
     */
    @Preview(MACHINE_MAN)
    public GHApp getApp() throws IOException {
<span class="fc" id="L1189">        return createRequest().withPreview(MACHINE_MAN).withUrlPath(&quot;/app&quot;).fetch(GHApp.class);</span>
    }

    /**
     * Returns the GitHub App identified by the given slug
     *
     * @param slug
     *            the slug of the application
     * @return the app
     * @throws IOException
     *             the IO exception
     * @see &lt;a href=&quot;https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#get-an-app&quot;&gt;Get an app&lt;/a&gt;
     */
    public GHApp getApp(@Nonnull String slug) throws IOException {
<span class="fc" id="L1203">        return createRequest().withUrlPath(&quot;/apps/&quot; + slug).fetch(GHApp.class);</span>
    }

    /**
     * Creates a GitHub App from a manifest.
     *
     * @param code
     *            temporary code returned during the manifest flow
     * @return the app
     * @throws IOException
     *             the IO exception
     * @see &lt;a href=
     *      &quot;https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-a-github-app-from-a-manifest&quot;&gt;Get an
     *      app&lt;/a&gt;
     */
    public GHAppFromManifest createAppFromManifest(@Nonnull String code) throws IOException {
<span class="fc" id="L1219">        return createRequest().method(&quot;POST&quot;)</span>
<span class="fc" id="L1220">                .withUrlPath(&quot;/app-manifests/&quot; + code + &quot;/conversions&quot;)</span>
<span class="fc" id="L1221">                .fetch(GHAppFromManifest.class);</span>
    }

    /**
     * Returns the GitHub App Installation associated with the authentication credentials used.
     * &lt;p&gt;
     * You must use an installation token to access this endpoint; otherwise consider {@link #getApp()} and its various
     * ways of retrieving installations.
     *
     * @return the app
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://docs.github.com/en/rest/apps/installations&quot;&gt;GitHub App installations&lt;/a&gt;
     */
    @Preview(MACHINE_MAN)
    public GHAuthenticatedAppInstallation getInstallation() throws IOException {
<span class="fc" id="L1237">        return new GHAuthenticatedAppInstallation(this);</span>
    }

    /**
     * Ensures that the credential is valid.
     *
     * @return the boolean
     */
    public boolean isCredentialValid() {
<span class="fc" id="L1246">        return client.isCredentialValid();</span>
    }

    /**
     * Provides a list of GitHub's IP addresses.
     *
     * @return an instance of {@link GHMeta}
     * @throws IOException
     *             if the credentials supplied are invalid or if you're trying to access it as a GitHub App via the JWT
     *             authentication
     * @see &lt;a href=&quot;https://developer.github.com/v3/meta/#meta&quot;&gt;Get Meta&lt;/a&gt;
     */
    public GHMeta getMeta() throws IOException {
<span class="fc" id="L1259">        return this.sanityCachedMeta.get(() -&gt; createRequest().withUrlPath(&quot;/meta&quot;).fetch(GHMeta.class));</span>
    }

    /**
     * Gets project.
     *
     * @param id
     *            the id
     * @return the project
     * @throws IOException
     *             the io exception
     */
    public GHProject getProject(long id) throws IOException {
<span class="fc" id="L1272">        return createRequest().withPreview(INERTIA).withUrlPath(&quot;/projects/&quot; + id).fetch(GHProject.class);</span>
    }

    /**
     * Gets project column.
     *
     * @param id
     *            the id
     * @return the project column
     * @throws IOException
     *             the io exception
     */
    public GHProjectColumn getProjectColumn(long id) throws IOException {
<span class="fc" id="L1285">        return createRequest().withPreview(INERTIA)</span>
<span class="fc" id="L1286">                .withUrlPath(&quot;/projects/columns/&quot; + id)</span>
<span class="fc" id="L1287">                .fetch(GHProjectColumn.class)</span>
<span class="fc" id="L1288">                .lateBind(this);</span>
    }

    /**
     * Gets project card.
     *
     * @param id
     *            the id
     * @return the project card
     * @throws IOException
     *             the io exception
     */
    public GHProjectCard getProjectCard(long id) throws IOException {
<span class="fc" id="L1301">        return createRequest().withPreview(INERTIA)</span>
<span class="fc" id="L1302">                .withUrlPath(&quot;/projects/columns/cards/&quot; + id)</span>
<span class="fc" id="L1303">                .fetch(GHProjectCard.class)</span>
<span class="fc" id="L1304">                .lateBind(this);</span>
    }

    /**
     * Tests the connection.
     *
     * &lt;p&gt;
     * Verify that the API URL and credentials are valid to access this GitHub.
     *
     * &lt;p&gt;
     * This method returns normally if the endpoint is reachable and verified to be GitHub API URL. Otherwise this
     * method throws {@link IOException} to indicate the problem.
     *
     * @throws IOException
     *             the io exception
     */
    public void checkApiUrlValidity() throws IOException {
<span class="fc" id="L1321">        client.checkApiUrlValidity();</span>
<span class="fc" id="L1322">    }</span>

    /**
     * Search commits.
     *
     * @return the gh commit search builder
     */
    @Preview(Previews.CLOAK)
    public GHCommitSearchBuilder searchCommits() {
<span class="fc" id="L1331">        return new GHCommitSearchBuilder(this);</span>
    }

    /**
     * Search issues.
     *
     * @return the gh issue search builder
     */
    public GHIssueSearchBuilder searchIssues() {
<span class="fc" id="L1340">        return new GHIssueSearchBuilder(this);</span>
    }

    /**
     * Search for pull requests.
     *
     * @return gh pull request search builder
     */
    public GHPullRequestSearchBuilder searchPullRequests() {
<span class="fc" id="L1349">        return new GHPullRequestSearchBuilder(this);</span>
    }

    /**
     * Search users.
     *
     * @return the gh user search builder
     */
    public GHUserSearchBuilder searchUsers() {
<span class="fc" id="L1358">        return new GHUserSearchBuilder(this);</span>
    }

    /**
     * Search repositories.
     *
     * @return the gh repository search builder
     */
    public GHRepositorySearchBuilder searchRepositories() {
<span class="fc" id="L1367">        return new GHRepositorySearchBuilder(this);</span>
    }

    /**
     * Search content.
     *
     * @return the gh content search builder
     */
    public GHContentSearchBuilder searchContent() {
<span class="fc" id="L1376">        return new GHContentSearchBuilder(this);</span>
    }

    /**
     * List all the notifications.
     *
     * @return the gh notification stream
     */
    public GHNotificationStream listNotifications() {
<span class="fc" id="L1385">        return new GHNotificationStream(this, &quot;/notifications&quot;);</span>
    }

    /**
     * This provides a dump of every public repository, in the order that they were created.
     *
     * @return the paged iterable
     * @see &lt;a href=&quot;https://developer.github.com/v3/repos/#list-all-public-repositories&quot;&gt;documentation&lt;/a&gt;
     */
    public PagedIterable&lt;GHRepository&gt; listAllPublicRepositories() {
<span class="fc" id="L1395">        return listAllPublicRepositories(null);</span>
    }

    /**
     * This provides a dump of every public repository, in the order that they were created.
     *
     * @param since
     *            The numeric ID of the last Repository that youve seen. See {@link GHRepository#getId()}
     * @return the paged iterable
     * @see &lt;a href=&quot;https://developer.github.com/v3/repos/#list-all-public-repositories&quot;&gt;documentation&lt;/a&gt;
     */
    public PagedIterable&lt;GHRepository&gt; listAllPublicRepositories(final String since) {
<span class="fc" id="L1407">        return createRequest().with(&quot;since&quot;, since).withUrlPath(&quot;/repositories&quot;).toIterable(GHRepository[].class, null);</span>
    }

    /**
     * Render a Markdown document in raw mode.
     *
     * &lt;p&gt;
     * It takes a Markdown document as plaintext and renders it as plain Markdown without a repository context (just
     * like a README.md file is rendered  this is the simplest way to preview a readme online).
     *
     * @param text
     *            the text
     * @return the reader
     * @throws IOException
     *             the io exception
     * @see GHRepository#renderMarkdown(String, MarkdownMode) GHRepository#renderMarkdown(String, MarkdownMode)
     */
    public Reader renderMarkdown(String text) throws IOException {
<span class="fc" id="L1425">        return new InputStreamReader(</span>
<span class="fc" id="L1426">                createRequest().method(&quot;POST&quot;)</span>
<span class="fc" id="L1427">                        .with(new ByteArrayInputStream(text.getBytes(&quot;UTF-8&quot;)))</span>
<span class="fc" id="L1428">                        .contentType(&quot;text/plain;charset=UTF-8&quot;)</span>
<span class="fc" id="L1429">                        .withUrlPath(&quot;/markdown/raw&quot;)</span>
<span class="fc" id="L1430">                        .fetchStream(Requester::copyInputStream),</span>
                &quot;UTF-8&quot;);
    }

    /**
     * Gets an {@link ObjectWriter} that can be used to convert data objects in this library to JSON.
     *
     * If you must convert data object in this library to JSON, the {@link ObjectWriter} returned by this method is the
     * only supported way of doing so. This {@link ObjectWriter} can be used to convert any library data object to JSON
     * without throwing an exception.
     *
     * WARNING: While the JSON generated is generally expected to be stable, it is not part of the API of this library
     * and may change without warning. Use with extreme caution.
     *
     * @return an {@link ObjectWriter} instance that can be further configured.
     */
    @Nonnull
    public static ObjectWriter getMappingObjectWriter() {
<span class="fc" id="L1448">        return GitHubClient.getMappingObjectWriter();</span>
    }

    /**
     * Gets an {@link ObjectReader} that can be used to convert JSON into library data objects.
     *
     * If you must manually create library data objects from JSON, the {@link ObjectReader} returned by this method is
     * the only supported way of doing so.
     *
     * WARNING: Objects generated from this method have limited functionality. They will not throw when being crated
     * from valid JSON matching the expected object, but they are not guaranteed to be usable beyond that. Use with
     * extreme caution.
     *
     * @return an {@link ObjectReader} instance that can be further configured.
     */
    @Nonnull
    public static ObjectReader getMappingObjectReader() {
<span class="fc" id="L1465">        return GitHubClient.getMappingObjectReader(GitHub.offline());</span>
    }

    /**
     * Gets the client.
     *
     * @return the client
     */
    @Nonnull
    GitHubClient getClient() {
<span class="fc" id="L1475">        return client;</span>
    }

    /**
     * Creates the request.
     *
     * @return the requester
     */
    @Nonnull
    Requester createRequest() {
<span class="fc" id="L1485">        Requester requester = new Requester(client);</span>
<span class="fc" id="L1486">        requester.injectMappingValue(this);</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">        if (!this.getClass().equals(GitHub.class)) {</span>
            // For classes that extend GitHub, treat them still as a GitHub instance
<span class="fc" id="L1489">            requester.injectMappingValue(GitHub.class.getName(), this);</span>
        }
<span class="fc" id="L1491">        return requester;</span>
    }

    /**
     * Intern.
     *
     * @param user
     *            the user
     * @return the GH user
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    GHUser intern(GHUser user) throws IOException {
<span class="fc bfc" id="L1504" title="All 2 branches covered.">        if (user != null) {</span>
            // if we already have this user in our map, get it
            // if not, remember this new user
<span class="fc" id="L1507">            GHUser existingUser = users.putIfAbsent(user.getLogin(), user);</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">            if (existingUser != null) {</span>
<span class="fc" id="L1509">                user = existingUser;</span>
            }
        }
<span class="fc" id="L1512">        return user;</span>
    }

<span class="fc" id="L1515">    private static final Logger LOGGER = Logger.getLogger(GitHub.class.getName());</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>