<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GitHubRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub API for Java</a> &gt; <a href="index.source.html" class="el_package">org.kohsuke.github</a> &gt; <span class="el_source">GitHubRequest.java</span></div><h1>GitHubRequest.java</h1><pre class="source lang-java linenums">package org.kohsuke.github;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.kohsuke.github.connector.GitHubConnectorRequest;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.WillClose;

import static java.util.Arrays.asList;

// TODO: Auto-generated Javadoc
/**
 * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to
 * retrieve from a GitHub server. Use the {@link Builder} to construct a {@link GitHubRequest}.
 * &lt;p&gt;
 * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should
 * be used to return different types of data could be handled in some other way. However, the return type is currently
 * not specified until late in the building process, so this is still untyped.
 * &lt;/p&gt;
 *
 * @author Liam Newman
 */
public class GitHubRequest implements GitHubConnectorRequest {

    /**
     * The Class Entry.
     */
    protected static class Entry {

        /** The key. */
        final String key;

        /** The value. */
        final Object value;

        /**
         * Instantiates a new entry.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         */
<span class="fc" id="L60">        protected Entry(String key, Object value) {</span>
<span class="fc" id="L61">            this.key = key;</span>
<span class="fc" id="L62">            this.value = value;</span>
<span class="fc" id="L63">        }</span>
    }

    /**
     * Class {@link Builder} follows the builder pattern for {@link GitHubRequest}.
     *
     * @param &lt;B&gt;
     *            The type of {@link Builder} to return from the various &quot;with*&quot; methods.
     */
    static class Builder&lt;B extends Builder&lt;B&gt;&gt; {

        /**
         * The base GitHub API for this request.
         */
        @Nonnull
        private String apiUrl;

        @Nonnull
        private final List&lt;Entry&gt; args;

        private byte[] body;

        private boolean forceBody;

        /**
         * The header values for this request.
         */
        @Nonnull
        private final Map&lt;String, List&lt;String&gt;&gt; headers;
        /**
         * Injected local data map
         */
        @Nonnull
        private final Map&lt;String, Object&gt; injectedMappingValues;

        /**
         * Request method.
         */
        @Nonnull
        private String method;

        @Nonnull
        private RateLimitTarget rateLimitTarget;
        @Nonnull
        private String urlPath;

        private Builder(@Nonnull List&lt;Entry&gt; args,
                @Nonnull Map&lt;String, List&lt;String&gt;&gt; headers,
                @Nonnull Map&lt;String, Object&gt; injectedMappingValues,
                @Nonnull String apiUrl,
                @Nonnull String urlPath,
                @Nonnull String method,
                @Nonnull RateLimitTarget rateLimitTarget,
                @CheckForNull byte[] body,
<span class="fc" id="L117">                boolean forceBody) {</span>
<span class="fc" id="L118">            this.args = new ArrayList&lt;&gt;(args);</span>
<span class="fc" id="L119">            TreeMap&lt;String, List&lt;String&gt;&gt; caseInsensitiveMap = new TreeMap&lt;&gt;(nullableCaseInsensitiveComparator);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : headers.entrySet()) {</span>
<span class="fc" id="L121">                caseInsensitiveMap.put(entry.getKey(), new ArrayList&lt;&gt;(entry.getValue()));</span>
<span class="fc" id="L122">            }</span>
<span class="fc" id="L123">            this.headers = caseInsensitiveMap;</span>
<span class="fc" id="L124">            this.injectedMappingValues = new LinkedHashMap&lt;&gt;(injectedMappingValues);</span>
<span class="fc" id="L125">            this.apiUrl = apiUrl;</span>
<span class="fc" id="L126">            this.urlPath = urlPath;</span>
<span class="fc" id="L127">            this.method = method;</span>
<span class="fc" id="L128">            this.rateLimitTarget = rateLimitTarget;</span>
<span class="fc" id="L129">            this.body = body;</span>
<span class="fc" id="L130">            this.forceBody = forceBody;</span>
<span class="fc" id="L131">        }</span>

        /**
         * Create a new {@link GitHubRequest.Builder}
         */
        protected Builder() {
<span class="fc" id="L137">            this(new ArrayList&lt;&gt;(),</span>
                    new TreeMap&lt;&gt;(nullableCaseInsensitiveComparator),
                    new LinkedHashMap&lt;&gt;(),
                    GitHubClient.GITHUB_URL,
                    &quot;/&quot;,
                    &quot;GET&quot;,
                    RateLimitTarget.CORE,
                    null,
                    false);
<span class="fc" id="L146">        }</span>

        /**
         * Builds a {@link GitHubRequest} from this builder.
         *
         * @return a {@link GitHubRequest}
         * @throws GHException
         *             wrapping a {@link MalformedURLException} if the GitHub API URL cannot be constructed
         */
        public GitHubRequest build() {
<span class="fc" id="L156">            return new GitHubRequest(args,</span>
                    headers,
                    injectedMappingValues,
                    apiUrl,
                    urlPath,
                    method,
                    rateLimitTarget,
                    body,
                    forceBody);
        }

        /**
         * Content type requester.
         *
         * @param contentType
         *            the content type
         * @return the request builder
         */
        public B contentType(String contentType) {
<span class="fc" id="L175">            this.setHeader(&quot;Content-type&quot;, contentType);</span>
<span class="fc" id="L176">            return (B) this;</span>
        }

        /**
         * Small number of GitHub APIs use HTTP methods somewhat inconsistently, and use a body where it's not expected.
         * Normally whether parameters go as query parameters or a body depends on the HTTP verb in use, but this method
         * forces the parameters to be sent as a body.
         *
         * @return the request builder
         */
        public B inBody() {
<span class="fc" id="L187">            forceBody = true;</span>
<span class="fc" id="L188">            return (B) this;</span>
        }

        /**
         * Object to inject into binding.
         *
         * @param value
         *            the value
         * @return the request builder
         */
        public B injectMappingValue(@NonNull Object value) {
<span class="fc" id="L199">            return injectMappingValue(value.getClass().getName(), value);</span>
        }

        /**
         * Object to inject into binding.
         *
         * @param name
         *            the name
         * @param value
         *            the value
         * @return the request builder
         */
        public B injectMappingValue(@NonNull String name, Object value) {
<span class="fc" id="L212">            this.injectedMappingValues.put(name, value);</span>
<span class="fc" id="L213">            return (B) this;</span>
        }

        /**
         * Method requester.
         *
         * @param method
         *            the method
         * @return the request builder
         */
        public B method(@Nonnull String method) {
<span class="fc" id="L224">            this.method = method;</span>
<span class="fc" id="L225">            return (B) this;</span>
        }

        /**
         * Method requester.
         *
         * @param rateLimitTarget
         *            the rate limit target for this request. Default is {@link RateLimitTarget#CORE}.
         * @return the request builder
         */
        public B rateLimit(@Nonnull RateLimitTarget rateLimitTarget) {
<span class="fc" id="L236">            this.rateLimitTarget = rateLimitTarget;</span>
<span class="fc" id="L237">            return (B) this;</span>
        }

        /**
         * Removes all arg entries for a specific key.
         *
         * @param key
         *            the key
         * @return the request builder
         */
        public B remove(String key) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">            for (int index = 0; index &lt; args.size();) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (args.get(index).key.equals(key)) {</span>
<span class="fc" id="L250">                    args.remove(index);</span>
                } else {
<span class="fc" id="L252">                    index++;</span>
                }
            }
<span class="fc" id="L255">            return (B) this;</span>
        }

        /**
         * Removes the named request HTTP header.
         *
         * @param name
         *            the name
         * @return the request builder
         */
        public B removeHeader(String name) {
<span class="fc" id="L266">            headers.remove(name);</span>
<span class="fc" id="L267">            return (B) this;</span>
        }

        /**
         * Unlike {@link #with(String, String)}, overrides the existing value.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B set(String key, Object value) {
<span class="fc" id="L280">            remove(key);</span>
<span class="fc" id="L281">            return with(key, value);</span>

        }

        /**
         * Sets the request HTTP header.
         * &lt;p&gt;
         * If a header of the same name is already set, this method overrides it.
         *
         * @param name
         *            the name
         * @param value
         *            the value
         * @return the request builder
         */
        public B setHeader(String name, String value) {
<span class="fc" id="L297">            List&lt;String&gt; field = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L298">            field.add(value);</span>
<span class="fc" id="L299">            headers.put(name, field);</span>
<span class="fc" id="L300">            return (B) this;</span>
        }

        /**
         * With requester.
         *
         * @param body
         *            the body
         * @return the request builder
         * @throws IOException
         *             Signals that an I/O exception has occurred.
         */
        public B with(@WillClose InputStream body) throws IOException {
<span class="fc" id="L313">            this.body = IOUtils.toByteArray(body);</span>
<span class="fc" id="L314">            IOUtils.closeQuietly(body);</span>
<span class="fc" id="L315">            return (B) this;</span>
        }

        /**
         * With requester.
         *
         * @param map
         *            map of key value pairs to add
         * @return the request builder
         */
        public B with(Map&lt;String, Object&gt; map) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L327">                with(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L328">            }</span>

<span class="fc" id="L330">            return (B) this;</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, Collection&lt;?&gt; value) {
<span class="fc" id="L343">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param e
         *            the e
         * @return the request builder
         */
        public B with(String key, Enum&lt;?&gt; e) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (e == null)</span>
<span class="fc" id="L357">                return with(key, (Object) null);</span>
<span class="fc" id="L358">            return with(key, transformEnum(e));</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, Map&lt;?, ?&gt; value) {
<span class="fc" id="L371">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, Object value) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L385">                args.add(new Entry(key, value));</span>
            }
<span class="fc" id="L387">            return (B) this;</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, String value) {
<span class="fc" id="L400">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, boolean value) {
<span class="fc" id="L413">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, int value) {
<span class="fc" id="L426">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, long value) {
<span class="fc" id="L439">            return with(key, (Object) value);</span>
        }

        /**
         * With preview.
         *
         * @param name
         *            the name
         * @return the b
         */
        public B withAccept(String name) {
<span class="fc" id="L450">            return withHeader(&quot;Accept&quot;, name);</span>
        }

        /**
         * With header requester.
         *
         * @param url
         *            the url
         * @return the request builder
         */
        public B withApiUrl(String url) {
<span class="fc" id="L461">            this.apiUrl = url;</span>
<span class="fc" id="L462">            return (B) this;</span>
        }

        /**
         * With header requester.
         *
         * @param name
         *            the name
         * @param value
         *            the value
         * @return the request builder
         */
        public B withHeader(String name, String value) {
<span class="fc" id="L475">            List&lt;String&gt; field = headers.get(name);</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="fc" id="L477">                setHeader(name, value);</span>
            } else {
<span class="nc" id="L479">                field.add(value);</span>
            }
<span class="fc" id="L481">            return (B) this;</span>
        }

        /**
         * With nullable requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B withNullable(String key, Object value) {
<span class="fc" id="L494">            args.add(new Entry(key, value));</span>
<span class="fc" id="L495">            return (B) this;</span>
        }

        /**
         * Path component of api URL. Appended to api url.
         * &lt;p&gt;
         * If urlPath starts with a slash, it will be URI encoded as a path. If it starts with anything else, it will be
         * used as is.
         *
         * @param urlPath
         *            the url path
         * @param urlPathItems
         *            the content type
         * @return the request builder
         */
        public B withUrlPath(@Nonnull String urlPath, @Nonnull String... urlPathItems) {
            // full url may be set and reset as needed
<span class="fc bfc" id="L512" title="All 4 branches covered.">            if (urlPathItems.length == 0 &amp;&amp; !urlPath.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L513">                return setRawUrlPath(urlPath);</span>
            }

            // Once full url is set, do not allow path setting
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            if (!this.urlPath.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L518">                throw new GHException(&quot;Cannot append to url path after setting a full url&quot;);</span>
            }

<span class="fc" id="L521">            String tailUrlPath = urlPath;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            if (urlPathItems.length != 0) {</span>
<span class="fc" id="L523">                tailUrlPath += &quot;/&quot; + String.join(&quot;/&quot;, urlPathItems);</span>
            }

<span class="fc" id="L526">            tailUrlPath = StringUtils.prependIfMissing(tailUrlPath, &quot;/&quot;);</span>

<span class="fc" id="L528">            this.urlPath = urlPathEncode(tailUrlPath);</span>
<span class="fc" id="L529">            return (B) this;</span>
        }

        /**
         * NOT FOR PUBLIC USE. Do not make this method public.
         * &lt;p&gt;
         * Sets the path component of api URL without URI encoding.
         * &lt;p&gt;
         * Should only be used when passing a literal URL field from a GHObject, such as {@link GHContent#refresh()} or
         * when needing to set query parameters on requests methods that don't usually have them, such as
         * {@link GHRelease#uploadAsset(String, InputStream, String)}.
         *
         * @param rawUrlPath
         *            the content type
         * @return the request builder
         */
        B setRawUrlPath(@Nonnull String rawUrlPath) {
<span class="fc" id="L546">            Objects.requireNonNull(rawUrlPath);</span>
            // This method should only work for full urls, which must start with &quot;http&quot;
<span class="fc bfc" id="L548" title="All 2 branches covered.">            if (!rawUrlPath.startsWith(&quot;http&quot;)) {</span>
<span class="fc" id="L549">                throw new GHException(&quot;Raw URL must start with 'http'&quot;);</span>
            }
<span class="fc" id="L551">            this.urlPath = rawUrlPath;</span>
<span class="fc" id="L552">            return (B) this;</span>
        }
    }
<span class="fc" id="L555">    private static final List&lt;String&gt; METHODS_WITHOUT_BODY = asList(&quot;GET&quot;, &quot;DELETE&quot;);</span>
<span class="fc" id="L556">    private static final Comparator&lt;String&gt; nullableCaseInsensitiveComparator = Comparator</span>
<span class="fc" id="L557">            .nullsFirst(String.CASE_INSENSITIVE_ORDER);</span>
    /**
     * Encode the path to url safe string.
     *
     * @param value
     *            string to be path encoded.
     * @return The encoded string.
     */
    private static String urlPathEncode(String value) {
        try {
<span class="fc" id="L567">            return new URI(null, null, value, null, null).toASCIIString();</span>
<span class="nc" id="L568">        } catch (URISyntaxException ex) {</span>
<span class="nc" id="L569">            throw new AssertionError(ex);</span>
        }
    }
    /**
     * Gets the final GitHub API URL.
     *
     * @param apiUrl
     *            the api url
     * @param tailApiUrl
     *            the tail api url
     * @return the api URL
     * @throws GHException
     *             wrapping a {@link MalformedURLException} if the GitHub API URL cannot be constructed
     */
    @Nonnull
    static URL getApiURL(String apiUrl, String tailApiUrl) {
        try {
<span class="fc bfc" id="L586" title="All 2 branches covered.">            if (!tailApiUrl.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L587">                apiUrl = &quot;&quot;;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">            } else if (&quot;github.com&quot;.equals(apiUrl)) {</span>
                // backward compatibility
<span class="fc" id="L590">                apiUrl = GitHubClient.GITHUB_URL;</span>
            }
<span class="fc" id="L592">            return new URI(apiUrl + tailApiUrl).toURL();</span>
<span class="fc" id="L593">        } catch (Exception e) {</span>
            // The data going into constructing this URL should be controlled by the GitHub API framework,
            // so a malformed URL here is a framework runtime error.
            // All callers of this method ended up wrapping and throwing GHException,
            // indicating the functionality should be moved to the common code path.
<span class="fc" id="L598">            throw new GHException(&quot;Unable to build GitHub API URL&quot;, e);</span>
        }
    }
    /**
     * Create a new {@link Builder}.
     *
     * @return a new {@link Builder}.
     */
    static Builder&lt;?&gt; newBuilder() {
<span class="fc" id="L607">        return new Builder&lt;&gt;();</span>
    }
    /**
     * Transform Java Enum into Github constants given its conventions.
     *
     * @param en
     *            Enum to be transformed
     * @return a String containing the value of a Github constant
     */
    static String transformEnum(Enum&lt;?&gt; en) {
        // by convention Java constant names are upper cases, but github uses
        // lower-case constants. GitHub also uses '-', which in Java we always
        // replace with '_'
<span class="fc" id="L620">        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');</span>
    }
    private final String apiUrl;
    private final List&lt;Entry&gt; args;
    private final byte[] body;

    private final boolean forceBody;

    private final Map&lt;String, List&lt;String&gt;&gt; headers;

    private final Map&lt;String, Object&gt; injectedMappingValues;

    private final String method;

    private final RateLimitTarget rateLimitTarget;

    private final URL url;

    private final String urlPath;

    @SuppressFBWarnings(value = { &quot;CT_CONSTRUCTOR_THROW&quot; }, justification = &quot;Basic argument validation&quot;)
    private GitHubRequest(@Nonnull List&lt;Entry&gt; args,
            @Nonnull Map&lt;String, List&lt;String&gt;&gt; headers,
            @Nonnull Map&lt;String, Object&gt; injectedMappingValues,
            @Nonnull String apiUrl,
            @Nonnull String urlPath,
            @Nonnull String method,
            @Nonnull RateLimitTarget rateLimitTarget,
            @CheckForNull byte[] body,
<span class="fc" id="L649">            boolean forceBody) {</span>
<span class="fc" id="L650">        this.args = Collections.unmodifiableList(new ArrayList&lt;&gt;(args));</span>
<span class="fc" id="L651">        TreeMap&lt;String, List&lt;String&gt;&gt; caseInsensitiveMap = new TreeMap&lt;&gt;(nullableCaseInsensitiveComparator);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : headers.entrySet()) {</span>
<span class="fc" id="L653">            caseInsensitiveMap.put(entry.getKey(), Collections.unmodifiableList(new ArrayList&lt;&gt;(entry.getValue())));</span>
<span class="fc" id="L654">        }</span>
<span class="fc" id="L655">        this.headers = Collections.unmodifiableMap(caseInsensitiveMap);</span>
<span class="fc" id="L656">        this.injectedMappingValues = Collections.unmodifiableMap(new LinkedHashMap&lt;&gt;(injectedMappingValues));</span>
<span class="fc" id="L657">        this.apiUrl = apiUrl;</span>
<span class="fc" id="L658">        this.urlPath = urlPath;</span>
<span class="fc" id="L659">        this.method = method;</span>
<span class="fc" id="L660">        this.rateLimitTarget = rateLimitTarget;</span>
<span class="fc" id="L661">        this.body = body;</span>
<span class="fc" id="L662">        this.forceBody = forceBody;</span>
<span class="fc" id="L663">        String tailApiUrl = buildTailApiUrl();</span>
<span class="fc" id="L664">        url = getApiURL(apiUrl, tailApiUrl);</span>
<span class="fc" id="L665">    }</span>

    /**
     * The headers for this request.
     *
     * @return the {@link Map} of headers
     */
    @Override
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Unmodifiable Map of unmodifiable lists&quot;)
    @Nonnull
    public Map&lt;String, List&lt;String&gt;&gt; allHeaders() {
<span class="fc" id="L676">        return headers;</span>
    }

    /**
     * The base GitHub API URL for this request represented as a {@link String}.
     *
     * @return the url string
     */
    @Nonnull
    public String apiUrl() {
<span class="nc" id="L686">        return apiUrl;</span>
    }

    /**
     * The arguments for this request. Depending on the {@link #method()} and {@code #inBody()} these maybe added to the
     * url or to the request body.
     *
     * @return the list of arguments
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Already unmodifiable&quot;)
    @Nonnull
    public List&lt;Entry&gt; args() {
<span class="fc" id="L698">        return args;</span>
    }

    /**
     * The {@link InputStream} to be sent as the body of this request.
     *
     * @return the {@link InputStream}.
     */
    @Override
    @CheckForNull
    public InputStream body() {
<span class="fc bfc" id="L709" title="All 2 branches covered.">        return body != null ? new ByteArrayInputStream(body) : null;</span>
    }

    /**
     * The content type to be sent by this request.
     *
     * @return the content type.
     */
    @Override
    public String contentType() {
<span class="fc" id="L719">        return header(&quot;Content-type&quot;);</span>
    }

    /**
     * Whether arguments for this request should be included in the URL or in the body of the request.
     *
     * @return true if the arguments should be sent in the body of the request.
     */
    @Override
    public boolean hasBody() {
<span class="fc bfc" id="L729" title="All 4 branches covered.">        return forceBody || !METHODS_WITHOUT_BODY.contains(method);</span>
    }

    /**
     * Gets the first value of a header field for this request.
     *
     * @param name
     *            the name of the header field.
     * @return the value of the header field, or {@code null} if the header isn't set.
     */
    @CheckForNull
    public String header(String name) {
<span class="fc" id="L741">        List&lt;String&gt; values = headers.get(name);</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (values != null) {</span>
<span class="fc" id="L743">            return values.get(0);</span>
        }
<span class="fc" id="L745">        return null;</span>
    }

    /**
     * The headers for this request.
     *
     * @return the {@link Map} of headers
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Already unmodifiable&quot;)
    @Nonnull
    public Map&lt;String, Object&gt; injectedMappingValues() {
<span class="fc" id="L756">        return injectedMappingValues;</span>
    }

    /**
     * The method for this request, such as &quot;GET&quot;, &quot;PATCH&quot;, or &quot;DELETE&quot;.
     *
     * @return the request method.
     */
    @Override
    @Nonnull
    public String method() {
<span class="fc" id="L767">        return method;</span>
    }

    /**
     * The rate limit target for this request.
     *
     * @return the rate limit to use for this request.
     */
    @Nonnull
    public RateLimitTarget rateLimitTarget() {
<span class="fc" id="L777">        return rateLimitTarget;</span>
    }

    /**
     * The {@link URL} for this request. This is the actual URL the {@link GitHubClient} will send this request to.
     *
     * @return the request {@link URL}
     */
    @Override
    @Nonnull
    public URL url() {
<span class="fc" id="L788">        return url;</span>
    }

    /**
     * The url path to be added to the {@link #apiUrl()} for this request. If this does not start with a &quot;/&quot;, it instead
     * represents the full url string for this request.
     *
     * @return a url path or full url string
     */
    @Nonnull
    public String urlPath() {
<span class="nc" id="L799">        return urlPath;</span>
    }

    private String buildTailApiUrl() {
<span class="fc" id="L803">        String tailApiUrl = urlPath;</span>
<span class="fc bfc" id="L804" title="All 6 branches covered.">        if (!hasBody() &amp;&amp; !args.isEmpty() &amp;&amp; tailApiUrl.startsWith(&quot;/&quot;)) {</span>
            try {
<span class="fc" id="L806">                StringBuilder argString = new StringBuilder();</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">                boolean questionMarkFound = tailApiUrl.indexOf('?') != -1;</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">                argString.append(questionMarkFound ? '&amp;' : '?');</span>

<span class="fc bfc" id="L810" title="All 2 branches covered.">                for (Iterator&lt;Entry&gt; it = args.listIterator(); it.hasNext();) {</span>
<span class="fc" id="L811">                    Entry arg = it.next();</span>
<span class="fc" id="L812">                    argString.append(URLEncoder.encode(arg.key, StandardCharsets.UTF_8.name()));</span>
<span class="fc" id="L813">                    argString.append('=');</span>
<span class="fc" id="L814">                    argString.append(URLEncoder.encode(arg.value.toString(), StandardCharsets.UTF_8.name()));</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">                    if (it.hasNext()) {</span>
<span class="fc" id="L816">                        argString.append('&amp;');</span>
                    }
<span class="fc" id="L818">                }</span>
<span class="fc" id="L819">                tailApiUrl += argString;</span>
<span class="nc" id="L820">            } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L821">                throw new GHException(&quot;UTF-8 encoding required&quot;, e);</span>
<span class="fc" id="L822">            }</span>
        }
<span class="fc" id="L824">        return tailApiUrl;</span>
    }

    /**
     * Create a {@link Builder} from this request. Initial values of the builder will be the same as this
     * {@link GitHubRequest}.
     *
     * @return a {@link Builder} based on this request.
     */
    Builder&lt;?&gt; toBuilder() {
<span class="fc" id="L834">        return new Builder&lt;&gt;(args,</span>
                headers,
                injectedMappingValues,
                apiUrl,
                urlPath,
                method,
                rateLimitTarget,
                body,
                forceBody);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>